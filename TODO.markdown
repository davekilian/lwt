
# Basic functionality

* Send non-textual input to the shell (e.g. arrow keys, Ctrl+\* signals)
* Print non-textual input from the shell using caret notation. 
  This is described in the ASCII character codes link above:

> Control characters are often rendered into a printable form known as caret 
> notation by printing a caret (^) and then the ASCII character that has a value 
> of the control character plus 64. Control characters generated using letter 
> keys are thus displayed with the upper-case form of the letter. For example, 
> ^G represents code 7, which is generated by pressing the G key when the 
> control key is held down.

# Input Lag

It takes about half a second for the terminal to print a character that was
just typed. What's going on? Probably lags due to Qt's event loops.

* There could be latency between the process writing text and the signal making
  it through the event queue
* There could be latency between receiving text and the update() event making
  it through the event queue

See if there's some way we can poll the QProcess manually on a watchdog thread

# Input Race Condition

This could be related to input lag, but: it seems it's possible for the shell
to write data to the screen before the input is echoed. Or something? 

If you type "help break" very quickly and type enter quickly, the first line
sometimes appears on the line buffer, which shouldn't happen ...

# Shell Driver

* Abstract system with at least three implementations:
    * A unix implementation that allocates a ptty and spawns a shell
    * A windows implementation that does hacky stuff with cmd.exe
      See the source for http://console.sf.net
    * An implementation that just spins up a shell binary

# Shell Options

* Create an options dialog
* Create options for picking your shell driver
* Create options for the shell drivers

# Infinite Scrollback

* Figure out how to store the input history in a way that makes scrolls though
  history efficient. For example, we might want to store lines separately so we
  can easily jump between lines

# Line Wrap

* Act like Terminal.app -- store the string without line wraps, but wrap the
  line dynamically when the window is resized. To make things easier in other
  places, it might make sense to store two buffers -- the canonical buffer that
  holds what came from the shell, and the view buffer that has line breaks
  based on the size of the current window. Then we can do draw calculations
  using the view buffer.

# Copy / Paste

* Ability to highlight text with the mouse cursor
* Hotkeys for copying and pasting

# Instance Spinup

* Create another instance of the process on Ctrl + N or something

# Color support

* Support control character codes for xterm-256 coloring
* Support theming
* Hardcode an attractive default theme

# Shell / Terminal Communication

For things like mouse events. Figure out how this works on UNIX. On Windows,
we'd need to forward mouse events to the hidden cmd.exe window or something.

# Smarter Scroll Behavior

The user should be able to scroll up somewhere and read the text while the
shell is spewing text below

